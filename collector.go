package periskop

import (
	"net/http"
	"runtime"
	"strings"
	"sync"

	"github.com/soundcloud/periskop-go/errutils"
)

// ErrorCollector collects all the aggregated errors
type ErrorCollector struct {
	aggregatedErrors sync.Map
}

// NewErrorCollector creates new ErrorCollector
func NewErrorCollector() ErrorCollector {
	return ErrorCollector{}
}

// Report adds an error to map of aggregated errors
func (c *ErrorCollector) Report(err error) {
	c.addError(err, HTTPContext{})
}

// ReportWithHTTPContext adds an error (with HTTPContext) to map of aggregated errors
func (c *ErrorCollector) ReportWithHTTPContext(err error, httpCtx HTTPContext) {
	c.addError(err, httpCtx)
}

// ReportWithHTTPRequest adds and error (with HTTPContext from http.Request) to map of aggregated errors
func (c *ErrorCollector) ReportWithHTTPRequest(err error, r *http.Request) {
	c.addError(err, HTTPContext{
		RequestMethod:  r.Method,
		RequestURL:     r.URL.String(),
		RequestHeaders: getAllHeaders(r.Header),
	})
}

// getAllHeaders gets all the headers of HTTP Request
func getAllHeaders(h http.Header) map[string]string {
	headersMap := make(map[string]string)
	for name, values := range h {
		for _, value := range values {
			headersMap[name] = value
		}
	}
	return headersMap
}

// getStackTrace gets the trace of the reported error
func getStackTrace(err error) []string {
	e := errutils.New(err)
	// get all the traces produced by the error skipping those
	// traces generated by this package.
	trace := string(e.Stack("periskop-go"))
	s := strings.Split(trace, "\n")
	return s
}

// functionCaller gets the caller of one of the Report functions.
// skip param in runtime.Caller func is set to 3 because we want
// to ascend 3 function calls until arrive to original function caller
func functionCaller() string {
	pc, _, _, ok := runtime.Caller(3)
	details := runtime.FuncForPC(pc)
	if ok && details != nil {
		return details.Name()
	}
	return ""
}

func (c *ErrorCollector) getAggregatedErrors() payload {
	aggregatedErrors := make([]*aggregatedError, 0)
	c.aggregatedErrors.Range(func(key, value interface{}) bool {
		aggregatedErr, _ := value.(*aggregatedError)
		aggregatedErrors = append(aggregatedErrors, aggregatedErr)
		return true
	})
	return payload{aggregatedErrors}
}

func (c *ErrorCollector) addError(err error, httpCtx HTTPContext) {
	errorInstance := newErrorInstance(err, functionCaller(), getStackTrace(err))
	errorWithContext := newErrorWithContext(errorInstance, SeverityError, httpCtx)
	aggregationKey := errorWithContext.aggregationKey()
	if aggregatedErr, ok := c.aggregatedErrors.Load(aggregationKey); ok {
		aggregatedErr, _ := aggregatedErr.(*aggregatedError)
		aggregatedErr.addError(errorWithContext)
	} else {
		aggregatedErr := newErrorAggregate(aggregationKey, SeverityError)
		aggregatedErr.addError(errorWithContext)
		c.aggregatedErrors.Store(aggregationKey, &aggregatedErr)
	}
}
