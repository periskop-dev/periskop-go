package periskop

import (
	"io"
	"io/ioutil"
	"net/http"
	"reflect"
	"strings"
	"sync"

	"github.com/google/uuid"
	"github.com/periskop-dev/periskop-go/errutils"
)

// ErrorReport represents a report of a single error
type ErrorReport struct {
	Err         error
	Severity    Severity
	HTTPRequest *http.Request
	HTTPCtx     *HTTPContext
	ErrKey      string
}

// ErrorCollector collects all the aggregated errors
type ErrorCollector struct {
	aggregatedErrors map[string]*aggregatedError
	mux              sync.RWMutex
	uuid             uuid.UUID
}

// NewErrorCollector creates a new ErrorCollector
func NewErrorCollector() ErrorCollector {
	return ErrorCollector{
		aggregatedErrors: make(map[string]*aggregatedError),
		uuid:             uuid.New(),
	}
}

// Report adds an error report to map of aggregated errors. Severity defaults to Error when missing.
func (c *ErrorCollector) Report(report ErrorReport) {
	if report.Severity == "" {
		report.Severity = SeverityError
	}
	if report.HTTPCtx == nil {
		report.HTTPCtx = httpRequestToContext(report.HTTPRequest)
	}
	c.addError(report.Err, report.Severity, report.HTTPCtx, report.ErrKey)
}

// ReportError adds an error with severity Error to map of aggregated errors
func (c *ErrorCollector) ReportError(err error) {
	c.ReportWithSeverity(err, SeverityError)
}

// ReportWithSeverity adds an error with given severity to map of aggregated errors
func (c *ErrorCollector) ReportWithSeverity(err error, severity Severity) {
	c.addError(err, severity, nil, "")
}

// ReportWithHTTPContext adds an error with severity Error (with HTTPContext) to map of aggregated errors
func (c *ErrorCollector) ReportWithHTTPContext(err error, httpCtx *HTTPContext) {
	c.ReportWithHTTPContextAndSeverity(err, SeverityError, httpCtx)
}

// ReportWithHTTPContextAndSeverity adds an error with given severity (with HTTPContext) to map of aggregated errors
func (c *ErrorCollector) ReportWithHTTPContextAndSeverity(err error, severity Severity, httpCtx *HTTPContext) {
	c.addError(err, severity, httpCtx, "")
}

// ReportWithHTTPRequest adds and error with severity Error  (with HTTPContext from http.Request) to map
// of aggregated errors
func (c *ErrorCollector) ReportWithHTTPRequest(err error, r *http.Request) {
	c.ReportWithHTTPRequestAndSeverity(err, SeverityError, r)
}

// ReportWithHTTPRequestAndSeverity adds and error with given severity (with HTTPContext from http.Request) to
// map of aggregated errors
func (c *ErrorCollector) ReportWithHTTPRequestAndSeverity(err error, severity Severity, r *http.Request) {
	c.addError(err, severity, httpRequestToContext(r), "")
}

// ReportErrorWithContext adds a manually generated ErrorWithContext to map of aggregated errors
func (c *ErrorCollector) ReportErrorWithContext(errWithContext ErrorWithContext, severity Severity, errKey string) {
	c.addErrorWithContext(errWithContext, severity, errKey)
}

func httpRequestToContext(r *http.Request) *HTTPContext {
	if r == nil {
		return nil
	}
	return &HTTPContext{
		RequestMethod:  r.Method,
		RequestURL:     r.URL.String(),
		RequestHeaders: getAllHeaders(r.Header),
		RequestBody:    getBody(r.Body),
	}
}

// getBody reads io.Reader request body and returns either body converted to a string or a nil
func getBody(body io.Reader) *string {
	if body == nil {
		return nil
	}
	r, err := ioutil.ReadAll(body)
	bodyAsString := string(r)
	if err != nil {
		return nil
	}
	return &bodyAsString
}

// getAllHeaders gets all the headers of HTTP Request
func getAllHeaders(h http.Header) map[string]string {
	headersMap := make(map[string]string)
	for name, values := range h {
		for _, value := range values {
			headersMap[name] = value
		}
	}
	return headersMap
}

// getStackTrace gets the trace of the reported error
func getStackTrace(err error) []string {
	e := errutils.New(err)
	// get all the traces produced by the error skipping those
	// traces generated by this package.
	trace := string(e.Stack("periskop-go"))
	s := strings.FieldsFunc(trace, func(c rune) bool { return c == '\n' })
	return s
}

func (c *ErrorCollector) getAggregatedErrors() payload {
	c.mux.RLock()
	defer c.mux.RUnlock()
	aggregatedErrors := make([]aggregatedError, 0)
	for _, value := range c.aggregatedErrors {
		aggregatedErrors = append(aggregatedErrors, *value)
	}
	return payload{aggregatedErrors, c.uuid}
}

// getAggregationKey gets the aggregation key of the error
// Specifying 'errKey' overrides the default aggregation method
func getAggregationKey(errorWithContext ErrorWithContext, errKey string) string {
	if len(errKey) > 0 {
		return errKey
	}
	return errorWithContext.aggregationKey()
}

// addError adds an error to map of aggregated errors
func (c *ErrorCollector) addError(err error, severity Severity, httpCtx *HTTPContext, errKey string) {
	errorInstance := newErrorInstance(err, reflect.TypeOf(err).String(), getStackTrace(err))
	errWithContext := NewErrorWithContext(errorInstance, severity, httpCtx)
	c.addErrorWithContext(errWithContext, severity, errKey)
}

// addErrorWithContext adds a manually generated ErrorWithContext to map of aggregated errors
func (c *ErrorCollector) addErrorWithContext(errWithContext ErrorWithContext, severity Severity, errKey string) {
	aggregationKey := getAggregationKey(errWithContext, errKey)
	c.mux.Lock()
	defer c.mux.Unlock()
	if aggregatedErr, ok := c.aggregatedErrors[aggregationKey]; ok {
		aggregatedErr.addError(errWithContext)
	} else {
		aggregatedErr := newAggregatedError(aggregationKey, severity)
		aggregatedErr.addError(errWithContext)
		c.aggregatedErrors[aggregationKey] = &aggregatedErr
	}
}
