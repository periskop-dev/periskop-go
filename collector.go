package periskop

import (
	"io"
	"io/ioutil"
	"net/http"
	"reflect"
	"strings"
	"sync"

	"github.com/soundcloud/periskop-go/errutils"
)

// ErrorCollector collects all the aggregated errors
type ErrorCollector struct {
	aggregatedErrors map[string]*aggregatedError
	mux              sync.RWMutex
}

// NewErrorCollector creates new ErrorCollector
func NewErrorCollector() ErrorCollector {
	return ErrorCollector{
		aggregatedErrors: make(map[string]*aggregatedError),
	}
}

// Report adds an error to map of aggregated errors
func (c *ErrorCollector) Report(err error) {
	c.addError(err, nil)
}

// ReportWithHTTPContext adds an error (with HTTPContext) to map of aggregated errors
func (c *ErrorCollector) ReportWithHTTPContext(err error, httpCtx *HTTPContext) {
	c.addError(err, httpCtx)
}

// ReportWithHTTPRequest adds and error (with HTTPContext from http.Request) to map of aggregated errors
func (c *ErrorCollector) ReportWithHTTPRequest(err error, r *http.Request) {
	c.addError(err, &HTTPContext{
		RequestMethod:  r.Method,
		RequestURL:     r.URL.String(),
		RequestHeaders: getAllHeaders(r.Header),
		RequestBody:    readBody(r.Body),
	})
}

// readBody reads io.Reader request body and returns either body converted to a string or a nil
func readBody(body io.Reader) *string {
	if body == nil {
		return nil
	}
	r, err := ioutil.ReadAll(body)
	bodyAsString := string(r)
	if err != nil {
		return nil
	} else {
		return &bodyAsString
	}
}

// getAllHeaders gets all the headers of HTTP Request
func getAllHeaders(h http.Header) map[string]string {
	headersMap := make(map[string]string)
	for name, values := range h {
		for _, value := range values {
			headersMap[name] = value
		}
	}
	return headersMap
}

// getStackTrace gets the trace of the reported error
func getStackTrace(err error) []string {
	e := errutils.New(err)
	// get all the traces produced by the error skipping those
	// traces generated by this package.
	trace := string(e.Stack("periskop-go"))
	s := strings.FieldsFunc(trace, func(c rune) bool { return c == '\n' })
	return s
}

func (c *ErrorCollector) getAggregatedErrors() payload {
	c.mux.RLock()
	defer c.mux.RUnlock()
	aggregatedErrors := make([]aggregatedError, 0)
	for _, value := range c.aggregatedErrors {
		aggregatedErrors = append(aggregatedErrors, *value)
	}
	return payload{aggregatedErrors}
}

func (c *ErrorCollector) addError(err error, httpCtx *HTTPContext) {
	errorInstance := newErrorInstance(err, reflect.TypeOf(err).String(), getStackTrace(err))
	errorWithContext := newErrorWithContext(errorInstance, SeverityError, httpCtx)
	aggregationKey := errorWithContext.aggregationKey()
	c.mux.Lock()
	defer c.mux.Unlock()
	if aggregatedErr, ok := c.aggregatedErrors[aggregationKey]; ok {
		aggregatedErr.addError(errorWithContext)
	} else {
		aggregatedErr := newAggregatedError(aggregationKey, SeverityError)
		aggregatedErr.addError(errorWithContext)
		c.aggregatedErrors[aggregationKey] = &aggregatedErr
	}
}
